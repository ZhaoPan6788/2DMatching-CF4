#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
File: batch_build.py
Author: Zili Chen
Email: chen__zili@163.com
Date: 2023-02-06
Description: A script for batch building Cmake projects.
"""

from base.check_compiler import check_compiler
from base.check_env import check_env_vars
from base.compile_cmake_project import compile_cmake_project
from base.copy_file_or_folder import copy_file_or_folder, copy_directory
from base.create_folder import create_folder
from base.filter_files_with_regex import filter_files_with_regex
from base.parse_command_line_input import parse_input
from base.import_json import import_json
from base.save_json_file import save_json_file

import os
import sys
import time
import copy

# generate mode
generate_mode_single_compilation = 10
generate_mode_repeated_compilation = 11

help_string = """A script for batch building Cmake projects.

usage: 
    python {} [options] [value]

options:
    -s/src      Path to source code directory. Default is ".".
    -d/dst      Path to destination directory. Default is ".".
    -n/name     Name of the working directory. Default is "iPM_work".
    -y          If set, the script silent running. Default is not set.
    -c/cores    Number of cores to use. Default is 4.
    -r/repeat   if set, each task is generated by recompiling the project.
    -h/help     Output help information.

"""
help_string = help_string.format(__file__)


def generate_tasks(json_data):
    """
    Arguments:
        json_data (dict): The dictionary object from the JSON file.
    
    Returns:
        dict: The dictionary object imported from the JSON file.
        
    Description:
        Import a JSON file and return the dictionary object.    
    """

    rho_list = [1e14, 1e15, 1e16, 1e17, 1e18]
    task_name = ["Rho_14", "Rho_15", "Rho_16", "Rho_17", "Rho_18"]

    json_list = []
    try:
        for i in range(len(rho_list)):
            d = copy.deepcopy(json_data)
            d["Plasma"]["initDensity"] = rho_list[i]
            json_list.append(d)

    except KeyError:
        print("The Key not found in the dictionary.")

    return json_list, task_name


def build_cmake_project(compilers=["ifort", "icc", "icpc"],
                        env_var_list=["HDF5_ENV_PATH", "PETSC_ENV_PATH"],
                        src_path=".",
                        dst_path=".",
                        work_dir_name="iPM_work",
                        src_code_dir_name="code",
                        cores_num=4,
                        silence_flag=False,
                        generate_mode=generate_mode_single_compilation,
                        generate_tasks_function=generate_tasks):

    """
        Build CMake Project for the given source code and compilers.

        Arguments:
            compilers (List[str]): List of compilers to use. Default is ["ifort", "icc", "icpc"].
            env_var_list (List[str]): List of environment variables. Default is ["HDF5_ENV_PATH", "PETSC_ENV_PATH", "FFTW_ENV_PATH"].
            src_path (str): Path to source code directory. Default is ".".
            dst_path (str): Path to destination directory. Default is ".".
            work_dir_name (str): Name of the working directory. Default is "iPM_work".
            src_code_dir_name (str): Name of the source code directory. Default is "code".
            cores_num (int): Number of cores to use. Default is 4.
            silence_flag (bool): If True, the script silent running. Default is False.
            generate_mode (function): Mode of task generation. Default is generate_mode_single_compilation.
            generate_tasks_function (function): Function to generate tasks. Default is generate_tasks.

        Returns:
            bool: True if all compilers exist, False otherwise.
            
        Description:
            The function builds a CMake project using the given compilers and environment variables for the source code located in `src_path` and creates the project files in `dst_path`. 
            The working directory will be created with the name `work_dir_name` in `dst_path`. The source code directory will have the name `src_code_dir_name` in the working directory. 
            The number of cores used during the build process is specified by `cores_num`. The `silence_flag` controls whether the program runs silently. 
            The `generate_mode` and `generate_tasks_function` parameters specify how the build tasks will be generated.
        """

    start_time = time.time()

    # Parse input
    input_dict = parse_input(sys.argv)
    if input_dict:
        try:
            if "s" in input_dict:
                src_path = input_dict["s"]

            if "src" in input_dict:
                src_path = input_dict["src"]

            if "d" in input_dict:
                dst_path = input_dict["d"]

            if "dst" in input_dict:
                dst_path = input_dict["dst"]

            if "n" in input_dict:
                work_dir_name = input_dict["n"]

            if "name" in input_dict:
                work_dir_name = input_dict["name"]

            if "y" in input_dict:
                silence_flag = input_dict["y"]

            if "c" in input_dict:
                cores_num = int(input_dict["c"])

            if "cores" in input_dict:
                cores_num = int(input_dict["cores"])

            if "r" in input_dict:
                generate_mode = generate_mode_repeated_compilation

            if "repeat" in input_dict:
                generate_mode = generate_mode_repeated_compilation

            if "h" in input_dict:
                print(help_string)
                return False

            if "help" in input_dict:
                print(help_string)
                return False

        except KeyError:
            print("The Key not found in the dictionary.")
        
        print("==> Parse input")
        print("Parsed command line input : ")
        for key, val in input_dict.items():
            print("\t{}: {}".format(key, val))

    print("")

    # Check compilers
    print("==> Check compilers")
    if check_compiler(compilers):
        print("All compilers exist.")
        print("")
    else:
        print("Some compilers do not exist.")
        return False

    # Check env vars
    print("==> Check env vars")
    if check_env_vars(env_var_list):
        print("All environment variables exist.")
        print("")
    else:
        print("Some environment variables do not exist.")
        return False

    # Confirm build information
    print("==> Confirm the following information")

    src_path = os.path.abspath(src_path)
    dst_path = os.path.abspath(dst_path)
    print("The path to the source Cmake project : {0}".format(src_path))
    print("The path to the target directory : {0}".format(
        os.path.join(dst_path, work_dir_name)))

    if not silence_flag:
        sure = input('Are you sure (yes/no): ')
        if sure not in ['y', 'Y', 'yes', 'Yes']:
            return False
    print("")

    # Create folder
    print("==> Create folder")
    if not create_folder(dst_path, work_dir_name):
        return False

    if not create_folder(os.path.join(dst_path, work_dir_name), src_code_dir_name):
        return False
    print("")

    # Copy files and folders
    print("==> Copy files and folders")
    src_matched_files = filter_files_with_regex(
        'src|lib|CMakeLists[.]txt|.+[.]cmake', src_path)
    config_matched_file = filter_files_with_regex('config[.]json', src_path)
    test_matched_file = filter_files_with_regex('test', src_path)
    input_matched_files = filter_files_with_regex('input', src_path)
    script_matched_files = filter_files_with_regex('script', src_path)
    matched_files = src_matched_files + config_matched_file + \
        test_matched_file + input_matched_files

    if script_matched_files:
        copy_file_or_folder(script_matched_files, src_path, os.path.join(dst_path, work_dir_name))

    if matched_files:
        matched_files = sorted(matched_files, reverse=True)
        print("Matched files/folders:")
        for file in matched_files:
            print("- {}".format(file))
        print("")
    else:
        print("No file was matched for build.")
        print("")
        return False

    if copy_file_or_folder(matched_files, src_path, os.path.join(dst_path, work_dir_name, src_code_dir_name)):
        print("Copying completed.")
        print("")
    else:
        print("Copying failure.")
        print("")

    # Generate tasks
    print("==> Generate tasks")
    json_file_name = config_matched_file[0]
    json_data = import_json(os.path.join(
        dst_path, work_dir_name, src_code_dir_name, json_file_name))
    jsons, tasks = generate_tasks_function(json_data)
    if tasks:
        print("The following execution tasks will be generated : ")
        for itask in tasks:
            print("-{0}".format(itask))
    else:
        print("No tasks to Generate.")
        print("")
        return False

    if not silence_flag:
        sure = input('Are you sure (yes/no): ')
        if sure not in ['y', 'Y', 'yes', 'Yes']:
            return False
    print("")

    # build
    print("==> Build")
    os.chdir(os.path.join(dst_path, work_dir_name, src_code_dir_name))
    print("Current working directory: {}".format(os.getcwd()))

    if generate_mode == generate_mode_single_compilation:
        save_json_file(os.path.join(dst_path, work_dir_name, src_code_dir_name),
                           json_file_name, jsons[0])
        compile_cmake_project(os.getcwd(), *compilers, cores_num)
        print("")

        for i in range(len(tasks)):
            copy_directory(os.path.join(dst_path, work_dir_name, src_code_dir_name, 'run'),
                           os.path.join(dst_path, work_dir_name, tasks[i]))
            save_json_file(os.path.join(dst_path, work_dir_name,
                                        tasks[i]), json_file_name, jsons[i])
            print("")

    elif generate_mode == generate_mode_repeated_compilation:
        for i in range(len(tasks)):
            save_json_file(os.path.join(dst_path, work_dir_name, src_code_dir_name),
                           json_file_name, jsons[i])
            compile_cmake_project(os.getcwd(), *compilers, cores_num)
            print("")

            copy_directory(os.path.join(dst_path, work_dir_name, src_code_dir_name, 'run'),
                           os.path.join(dst_path, work_dir_name, tasks[i]))
            save_json_file(os.path.join(dst_path, work_dir_name,
                                        tasks[i]), json_file_name, jsons[i])
            print("")

    else:
        print("No task generation mode was specified.")
        return False

    print("Generate completed.")
    print("")

    end_time = time.time()

    print("Date: {}".format(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())))
    print("Start time: {}".format(time.strftime(
        "%Y-%m-%d %H:%M:%S", time.localtime(start_time))))
    print("End time: {}".format(time.strftime(
        "%Y-%m-%d %H:%M:%S", time.localtime(end_time))))
    elapsed_time = end_time - start_time
    print("Elapsed time: {:.2f} seconds".format(elapsed_time))
    print("")

    return True


if __name__ == '__main__':
    build_cmake_project()
